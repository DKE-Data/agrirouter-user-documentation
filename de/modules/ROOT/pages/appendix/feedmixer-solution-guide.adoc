= Feedmixer Solution Guide

Nachfolgend soll die Nutzung der verfügbaren Szenarien Flows im Kontext des *Feedmixer-Datenaustausch* beschrieben werden. Auf der https://beta.isobus.net/isobus/efdi/scenario-definitions.html[ISO 5231 (EFDI)] kannst du die  verfügbaren Szenarien Flows auswählen und erhaltst für jeden Szenario Flow eine visuelle Darstellung einschließlich der Nachrichtendefinitionen im Protocol Buffers (Protobuf) Format zur Serialisierung der Daten.

Folgende Punkte werden in diesem Abschnitt behandelt:

* Was ist Protobuf?
* Das Feedmixer Protocol-Buffers-Schema kompilieren
* Beschreibung der Feedmixer Objekte
* Beschreibung der Szenarien Flows
* Beispiel Anwendungsfälle

[#what-is-protobuf]
== Was ist Protobuf?

*Protocol Buffers (Protobuf)* ist ein von Google entwickeltes Format zur Serialisierung von Daten. Es speichert strukturierte Daten effizient und kompakt in *binärer* Form und ermöglicht so eine schnellere Übertragung über Netzwerkverbindungen. Protobuf unterstützt eine breite Palette ausgewählter Programmiersprachen und ist plattformunabhängig, was bedeutet, dass Programme, die mit diesem Format geschrieben wurden, problemlos auf andere Plattformen portiert werden können.

Die sprachunabhängige Syntax ermöglicht es Programmen, die in verschiedenen Programmiersprachen geschrieben wurden, zuverlässig miteinander zu kommunizieren.

Darüber hinaus bietet das Format Protobuf mehrere Vorteile gegenüber anderen Formaten wie XML oder JSON. Da die strukturierten Daten im Binärformat gespeichert werden, sind sie viel kleiner als textbasierte Formate wie XML oder JSON, wodurch sie schneller über Netzwerke übertragen werden können. +
Zu den unterstützten Sprachen zählen unter anderem folgende:

* *C#*
* *C++*
* *Go*
* *Objective-C*
* *Java*
* *Python*
* *Ruby*

[#compile-feedmixer-protobuf]
== Das Feedmixer Protocol-Buffers-Schema kompilieren
Die Feedmixer-Datenstrukturen sind in ``.proto-``Dateien definiert, du kannst dir die Klassen, die zum Lesen und Schreiben der Protobuf-Nachrichten benötigt werden, generieren lassen. Zu diesem Zweck verwendest du den Protocol-Buffers-Compiler (protoc) auf die Konfigurationsdatei an. +
Sofern der Compiler noch nicht installiert ist, lade dir einfach die aktuelle Version im offiziellen https://github.com/protocolbuffers/protobuf/releases/[GitHub-Repository, window="_blank"] herunter. Entpacke die ZIP-Datei an gewünschter Stelle und starten den Compiler anschließend per Doppelklick (befindet sich im ``„bin“``-Ordner).

[NOTE]
====
Achte darauf, dass du die passende Edition des Protobuf-Compilers herunterlädst: Protoc ist wahlweise für *32- oder 64-Bit-Architekturen* (Windows, Linux oder macOS) verfügbar.
====

Abschließend spezifiziere

* das *Quell-Verzeichnis*, in dem der Code deines Programms liegt (hier Platzhalter ``„SRC_DIR"``),
* das *Ziel-Verzeichnis*, in das der generierte Code gespeichert werden soll (hier Platzhalter ``„DST_DIR“``)
und den *Pfad* zur den .proto-Dateien.
* Um beispielsweise *Java-Klassen* zu generieren, nutzen wir außerdem die Option ``--java_out`` (ähnliche Optionen gibt es auch für die anderen unterstützten Sprachen). Der vollständige Befehl für die Kompilierung lautet folgendermaßen:

+
[source]
-----------------
protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/*.proto
-----------------

[TIP]
====
Ein ausführlicheres Protobuf-Java-Tutorial, in dem unter anderem auch die Nachrichtenübertragung via Protocol Buffers (Lesen/Schreiben) erklärt wird, bietet Google in der „Developers“-Sektion an, dem hauseigenen Projektbereich des Suchmaschinenriesens für Entwickler. Alternativ hast du dort auch Zugriff auf Anleitungen für die anderen unterstützen Sprachen wie *C++, Go oder Python*.
====

[#feedmixer_objects]
== Beschreibung der Feedmixer Objekte

Übersicht der Feedmixer Objekte 
[cols="1,1"]
|===
|link:#area[``Area``]
|Beschreibung eines Bereichs

|link:#component[``Component``]
|Beschreibung einer Komponente

|link:#customer[``Customer``]
|Beschreibung des Kunden

|link:#device[``Device``]
|Beschreibung eines Futtermischwagens

|link:#group[``Group``]
|Beschreibung einer Tiergruppe

|link:#ingredient[``Ingredient``]
|Beschreibung einer Zutat

|link:#nutrients[``Nutrients``]
|Aktuelle Beschreibung der Nährstoffe

|link:#recipe[``Recipe``]
|Aktuelle Beschreibung eines Rezepts ``(Recipe)``

|link:#afterloadinglastingredient[``AfterLoadingLastIngredient``]
|Konfiguration des Misch-Verhaltens nach Zugabe der letzten Zutat

|link:#masterdata[``Masterdata``]
|Die Stammdaten/Masterdaten können über dieses Objekt synchronisiert werden.

|link:#masterdataresponse[``MasterdataResponse``]
|Verarbeitungsstatus der übertragenden Stammdaten

|link:#plannedloadlistwithdependencies[``PlannedLoadListWithDependencies``]
|Konfiguration einer geplanten Ladeliste.

|link:#plannedloadlistwithdependenciesresonse[``PlannedLoadListWithDependenciesResponse``]
|Verarbeitungsstatus der übertragenden Ladeliste

|link:#plannedloadlist[``PlannedLoadList``]
|Konfiguration einer geplanten Ladeliste mit allen dafür notwendigen Referenzen.

|link:#plannedloadlistgroup[``PlannedLoadListGroup``]
|Konfiguration einer Gruppe zu einer geplanten Ladeliste. 

|link:#plannedloadlistresponse[``PlannedLoadListResponse``]
|Verarbeitungsstatus der übertragenden Ladeliste

|link:#completeloadlistwithdependencies[``CompleteLoadListWithDependencies``]
|Beschreibunng des Ist-Zustandes zu einer Ladeliste.

|link:#completeloadlistwithdependenciesresponse[``CompleteLoadListWithDependenciesResponse``]
|Verarbeitungsstatus des übertragenden Ist-Zustandes zu einer Ladeliste.

|link:#completeloadlist[``CompleteLoadList``]
|Beschreibunng des Ist-Zustandes zu einer Ladeliste.

|link:#completeloadlistingredient[``CompleteLoadListIngredient``]
|Abgeschlossener Befüllvorgang einer Zutat

|link:#completeloadlistgroup[``CompleteLoadListGroup``]
|Dokumentation einer Gruppen-Fütterung zu einer geplanten Ladeliste.

|link:#completeloadlistwithdependenciesresponse[``CompleteLoadListWithDependenciesResponse``]
|Verarbeitungsstatus des übertragenden Ist-Zustandes zu einer Ladeliste.

|link:#refusalwithdependencies[``RefusalWithDependencies``]
|Dokumentation einer Futterverweigerung inklusiver notwendiger Masterdaten

|link:#refusalwithdependenciesresponse[``RefusalWithDependenciesResponse``]
|Verarbeitungsstatus der übertragenden Futterverweigerung.

|link:#refusal[``Refusal``]
|Futter Verweigerung 

|link:#refusalresponse[``RefusalResponse``]
|Verarbeitungsstatus der übertragenden Futterverweigerung.
|===

Die meisten Objekte beinnhalten eine ``UUID`` diese verweist eindeutig auf eine ID im verwendeten Softwaresystem. In den meisten Fällen wird weiterhin das Objekt durch einen Namen ``(string)`` beschrieben.

[source]
-----------------
// Universal Unique Identifier (UUID)
// A UUID () is a 128-bit value used to uniquely identify an object or entity 
// on the internet. Depending on the specific mechanisms used, a UUID is either 
// guaranteed to be different or is, at least, extremely likely to be different 
// from any other UUID generated.
// The UUID relies on a combination of components to ensure uniqueness. 
// UUIDs are constructed in a sequence of digits equal to 128 bits. 
// The ID is in hexadecimal digits, meaning it uses the numbers 0 through 9 and 
// letters A through F. The hexadecimal digits are grouped as 32 hexadecimal 
// characters with four hyphens: XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX. 
// The number of characters per hyphen is 8-4-4-4-12.
// e.g. 
//    111e8400-a56c-11d4-a616-8966554478aa
// 
message UUID {
	string value = 1;
}
-----------------

=== Stammdaten

[#area]
==== Bereiche
Beschreibung eines Bereichs ``(Area)``, dieses kann ein Ladepunkt ``(AreaType = A_LOADING_POINT)`` sein, hier werden Futterminttel beladen. 

Ein Stall ``(AreaType = A_BARN)``, in dem die gemixten Futtermittel entladen werden, wird ebenfalls über das Objekt beschrieben. +
Die Bereiche haben eine Referenz zu einem Kunden ``(Customer)``, diese erfogt über ``customer_id_ref``.

[source]
-----------------
// Area – ARS 
message Area {
	enum AreaType {
		A_LOADING_POINT = 0;
		A_BARN = 1;
		A_OTHER = 2;
	}

	UUID area_external_id = 1;	/// Uniquely references for the area in the sofware system used
	string area_name = 2;		/// Name of the area
	AreaType area_type = 3;		/// Type of the area (LoadingPoint, Barn, other) 
	UUID customer_id_ref = 4;	/// Internal reference
	repeated google.protobuf.Any extension = 2048;
}
-----------------

[#component]
==== Komponenten
Beschreibung einer Komponente ``(Component)``der Komponenten-Typ wird über den ``ComponentType`` beschrieben. 

Die Nähstoffe werden über das Objekt ``(Nutrients)`` angegeben. +
Die Referenz zu einem Beladeort ``(Area)`` wird über die ``area_id_ref`` konfiguriert.

[source]
-----------------
// Component – CMP
message Component {
	enum ComponentType {
		A_ROUGHAGE = 0;
		A_BY_PRODUCT = 1;
		A_CONCENTRATE = 2;
		A_FRESH_GRASS = 3;
		A_MINERAL = 4;
		A_MEDICATION = 5;
		A_OTHER = 6;
	}
	
	UUID component_external_id = 1;		/// Uniquely references for the component in the sofware system used
	string component_name = 2;			/// Name of the component
	ComponentType component_type = 3;	/// Type of the component
	Nutrients nutrients = 4;			/// Included Nutrients object
	UUID area_id_ref = 5;				/// Internal reference
	repeated google.protobuf.Any extension = 2048;
}
-----------------

[#customer]
==== Kunden
Beschreibung des Kunden ``(Customer)``.

[source]
-----------------
// Customer - CTR
message Customer {

	UUID customer_external_id = 1;	/// Uniquely references for the customer in the sofware system used
	string customer_name = 2;		/// Name of the customer
	repeated google.protobuf.Any extension = 2048;
}
-----------------

[#device]
==== Futtermischwagen 
Beschreibung eines Futtermischwagens ``(Device)``. 

Neben dem Namen ``(device_name)`` der Serialnummer ``(device_serial_number)`` wird die Ladekapazität ``(device_capacity)`` in der Einheit *kg* beschrieben. +
Über eine *White-List* ``(repeated UID area_id_ref)`` werden, die für diesen Futtermischwagen möglichen Be-, und Entladepunkte angegeben. 

[source]
-----------------
// Device – DVC 
message Device {
	
	UUID device_external_id = 1;		/// Uniquely references for the device in the sofware system used
	string device_serial_number = 2;	/// Serial number of the device assigned by the manufacturer
	string device_name = 3;				/// Name of the device
	uint64 device_capacity = 4;			/// Total KG capcaity of the mixer (treshold of overload). Unit: kg
	repeated UUID area_id_ref = 5;		/// White-List means, list of areas that can be accessed
	repeated google.protobuf.Any extension = 2048;
}
-----------------

[#group]
==== Tiergruppe
Beschreibung einer Tiergruppe ``(Group)`` der Tiergruppen-Typ wird über den ``GroupType `` beschrieben. 

Die Anzahl der Tiere dieser Tiergruppe wird in der Einheit *Stück* über den Parameter: ``(group_head_count )`` angegeben. +
Der relative Prozentsatz zur Anpassung der Futtermenge (Standardwert 100%) wird über den Faktor ``(group_feeding_factor)`` in der Einheit *%*, bestimmt. +
Die Länge des Futtertisches (in *m*) dieser Tiergruppe beschreibt der Parameter ``group_feeding_rack_length``. +
Die Referenz zu dem Bereich der Tiergruppe ``(Area)`` erfolgt über die ``area_id_ref``.

[source]
-----------------
// Group – GRP
message Group {
	enum GroupType {
		A_MILKING = 0;
		A_DRY = 1;
		A_BULLS = 2;
		A_OTHER = 3;
	}
	
	UUID group_external_id = 1;				/// Uniquely references for the group in the sofware system used
	string group_name = 2;					/// Name of the group
	GroupType group_type = 3;				/// Type of the group (milking, dry, bulls, other) 
	uint32 group_head_count = 4;			/// Total number of annimals for this group. Unit: piece
	uint32 group_feeding_factor = 5;		/// Relative percentage used to adjust feed amount for a group. (default 100%). Unit %
	uint32 group_feeding_rack_length = 6;	/// Length of feeding rack of the specific group. Unit m
	UUID area_id_ref = 7;					/// Internal reference
	repeated google.protobuf.Any extension = 2048;
}
-----------------

[#ingredient]
==== Zutaten
Beschreibung einer Zutat ``(Ingredient)`` und deren Anwendung.

Der Start-Modus Typ wird über den ``StartMode `` beschrieben. +
Die Menge pro Tier wird über den Parameter ``ingredient_quantity`` in der Einheit *kg/head* angegeben. +
Die Ladesequenz in der diese Zutat eingefüllt werden soll, beschreibt der Wert ``ingredient_order``. +
Der Mischvorgang zu dieser Zutat kann über die folgenden Werte konfiguriert werden:

* ``ingredient_mix_time`` in der Einheit *Sekunden*
* ``ingredient_mix_speed`` in der Einheit *RPM/min*
* ``ingredient_mix_rotations`` in der Einheit *RPM*

Der Startzeitpunkt des Mischvorgangs kann über den Parameter ``ingredient_start_percentage`` (Einheit *%*) gesteuert werden, d.h. wenn X Prozent eingefüllt sind, kann der Mischvorgang starten.

[source]
-----------------
// Ingredient – ING 
message Ingredient {
	enum StartMode {
		A_AUTO = 0;
		A_MANUAL = 1;
		A_OTHER = 2;
	}
	
	UUID ingredient_external_id = 1;			/// UUID of the ingredient used in the recipe
	UUID component_id_ref = 2;					/// Internal reference
	uint32 ingredient_quantity = 3;				/// Quantity (kg/head) actual load. Unit: kg/head
	uint32 ingredient_order = 4;				/// Loading position/ sequence in load list
	StartMode start_mode = 5;					/// Start mode (auto, maunual, other)										
	uint32 ingredient_mix_time = 6;				/// Total mix time expected during or after each ingredient. Unit sec
	uint32 ingredient_mix_speed = 7;			/// Mix speed expected for each ingredient. Unit RPM/min
	uint32 ingredient_mix_rotations = 8;		/// Mix rotations expected for each ingredient. Unit RPM
	uint32 ingredient_start_percentage = 9;		/// Starting percentage of the total weight of the current ingredient to start the mixer. Unit %
	repeated google.protobuf.Any extension = 2048;
}
-----------------

[#nutrients]
==== Nährstoffe
Aktuelle Beschreibung der Nährstoffe ``(Nutrients)``.

[source]
-----------------
// Nutrients - NUT
message Nutrients {
	double dry_matter = 1;	/// Expected dry matter percentage. Unit %
	repeated google.protobuf.Any extension = 2048;
}
-----------------

[#recipe]
==== Rezepte
Aktuelle Beschreibung eines Rezepts ``(Recipe)``. Der Parameter ``recipe_density`` gibt die Dichte pro *kg/m³* an.

Die Version des Rezepts wird über ``recipe_revision`` sichtbar gemacht.
Über das Kennzeichen ``recipe_premix`` wird bestimmt, ob das Rezept für eine Vormischung bestimmt ist. +
Die Zutatenliste und deren Befüll-Reihenfolge, wird über ``repeated Ingredient ingredient_ref`` konfiguriert. +
Das Misch-Verhalten nach der Zugabe der letzten Zutat wird über das Objekt: ``after_loading_last_ingredient`` beschrieben.

[source]
-----------------
// Recipe – RCP 
message Recipe {

	UUID recipe_external_id = 1;									/// Uniquely references for the recipe in the sofware system used
	string recipe_name = 2;											/// Name of the recipe
	uint32 recipe_density = 3;										/// Density of specific recipe. Unit kg/m³
	uint32 recipe_revision = 4;										/// Progressive ID to identify the different changes applied to the recipe
	bool recipe_premix = 5;											/// Flag to tell if the recipe is for a premix
	repeated Ingredient ingredient_ref = 6;							/// Included Ingredients array (ING)
	AfterLoadingLastIngredient after_loading_last_ingredient = 7;	/// Included After loading ingredient (ALI)
	repeated google.protobuf.Any extension = 2048;
}
-----------------

[#afterloadinglastingredient]
==== Misch-Verhalten nach Zugabe der letzten Zutat.
Konfiguration des Misch-Verhaltens nach Zugabe der letzten Zutat ``(AfterLoadingLastIngredient)``. Der Start-Modus Typ wird über den ``StartMode `` beschrieben. 

Der finale Mischvorgang kann über die folgenden Werte konfiguriert werden:

* ``afterloadinglastingredient_mix_time`` in der Einheit *Sekunden*
* ``afterloadinglastingredient_mix_speed`` in der Einheit *RPM/min*
* ``afterloadinglastingredient_mix_rotations`` in der Einheit *RPM*

[source]
-----------------
// AfterLoadingLastIngredient – ALI 
message AfterLoadingLastIngredient {
	enum StartMode {
		A_AUTO = 0;
		A_MANUAL = 1;
		A_OTHER = 2;
	}

	StartMode start_mode = 1;										
	uint32 afterloadinglastingredient_mix_time = 2;			/// Total mix time expected during or after the last ingredient. Unit sec
	uint32 afterloadinglastingredient_mix_speed = 3;		/// Mix speed expected for the last ingredient. Unit RPM/min
	uint32 afterloadinglastingredient_mix_rotations = 4;	/// Mix rotations expected for the last ingredient. Unit RPM
	repeated google.protobuf.Any extension = 2048;
}
-----------------

[#masterdata]
=== Masterdaten, Synchronisation
Die Stammdaten/Masterdaten können über dieses Objekt synchronisiert werden. +
Dieses Vorgehen wird über den Scenario-Flow ``(Sync MasterData)`` beschrieben.

[source]
-----------------
// MasterData for synchronization (SYNC verb).
message MasterData {
	
    repeated Area area = 1;
    repeated Component component = 2;
    repeated Customer customer = 3;
    repeated Device device = 4;
    repeated Group group = 5;
    repeated Ingredient ingredient = 6;
    repeated Recipe recipe = 7;
    repeated Worker worker = 8;
	repeated google.protobuf.Any extension = 2048;
}
-----------------

[#masterdataresponse]
==== Antwort-Objekt für übertragende MasterData
Über das Objekt ``MasterDataResponse`` wird der Verarbeitungsstatus der übertragenden Stammdaten ``(MasterData)`` über den ``response_code`` zurückgegeben.


[source]
-----------------
message MasterDataResponse {
    enum ResponseCode {
        OK = 0;                         /// No error occured
        CANNOT_PROCESS_MASTERDATA = 2;  /// Given MasterData cannot be processed
    }

    ResponseCode response_code = 1; /// Response code with processing information
    string response_text = 2;       /// Response text with human-readable information on why the MasterData cannot be processed

    repeated google.protobuf.Any extension = 2048;
}
-----------------

=== Bewegungsdaten

[#plannedloadlistwithdependencies]
==== Ladeliste inklusiver notwendiger Masterdaten
Konfiguration einer geplanten Ladeliste.

[NOTE]
====
Dieses Objekt beinhaltet auch alle notwendigen (referenzierenten) Masterdaten.
====

[source]
-----------------
// PlannedLoadListWithDependencies for synchronization
message PlannedLoadListWithDependencies {
	
    PlannedLoadList plannedLoadList = 1;
    repeated Area area = 2;
    repeated Component component = 3;
    repeated Customer customer = 4;
    repeated Device device = 5;
    repeated Group group = 6;
    repeated Ingredient ingredient = 7;
    repeated Nutrients nutrients = 8;
    repeated Recipe recipe = 9;
    repeated Worker worker = 10;
    repeated google.protobuf.Any extension = 2048;
}
-----------------

[#plannedloadlistwithdependenciesresponse]
==== Antwort-Objekt zu einer übertragenden Ladeliste
Über das Objekt ``PlannedLoadListWithDependenciesResponse`` wird zu einer übertragenden ``PlannedLoadListWithDependencies`` der Verarbeitungsstatus über den ``response_code`` zurückgegeben.

[source]
-----------------
message PlannedLoadListWithDependenciesResponse {
    enum ResponseCode {
        OK = 0;                                             /// No error occured
        CANNOT_PROCESS_PLANNEDLOADLISTWITHDEPENDENCIES = 2; /// Given PlannedLoadListWithDependencies cannot be processed
    }

    ResponseCode response_code = 1; /// Response code with processing information
    string response_text = 2;       /// Response text with human-readable information on why the PlannedLoadListWithDependencies cannot be processed

    repeated google.protobuf.Any extension = 2048;
}
-----------------

[#plannedloadlist]
==== Ladeliste
Konfiguration einer geplanten Ladeliste mit allen dafür notwendigen Referenzen.

[NOTE]
====
Dieses Objekt beinhaltet nur die Referenzen auf die notwendigen Stammdaten
====

Die ``plannedloadlist_id`` ist die Id der geplanten Ladeliste. Der Typ der Ladeliste wird über den ``PlannedLoadListType`` beschrieben. +
Über die UID ``recipe_id_ref`` wird die Referenz auf das anzuwendende Rezept hergestellt. Das erwarte Startdatum wird (im ISO 8601 Format) über den Parameter ``plannedloadlist_starttime```angegeben. +
Über Liste ``plannedloadlist_group`` vom Objekttyp ``PlannedLoadListGroup`` werden die zu fütternden Tiergruppen konfiguriert.

[source]
-----------------
// PlannedLoadList – PLL 
message PlannedLoadList {
	enum PlannedLoadListType {
		B_PLANNED = 0;
		B_ADHOC = 1;
		B_OTHER = 2;
	}

	UUID plannedloadlist_id = 1;								/// Uniquely references for the planned load list in the sofware system used
	PlannedLoadListType plannedloadlist_type  = 2;				/// Type of the planned load list (planned, adhoc, other)
	UUID recipe_id_ref = 3;										/// Internal reference
	string plannedloadlist_starttime = 4;						/// Expected start time. Datetime in ISO 8601 representation
	repeated PlannedLoadListGroup plannedloadlist_group = 5;    /// Included PlannedLoadListGroup object
	repeated google.protobuf.Any extension = 2048;
}
-----------------

[#plannedloadlistgroup]
==== Gruppenliste zu einer Ladeliste
Konfiguration einer Gruppe zu einer geplanten Ladeliste. 

Die Referenz zu einer Gruppe ``(Group)`` erfolgt über die ``group_id_ref``. +
Das erwarte Endladedatum wird (im ISO 8601 Format) über den Parameter ``plannedloadlistgroup_discharge_time``angegeben. +
Die Fütterungsreihenfolge dieser Gruppe wird über den Parameter ``plannedloadlistgroup_order`` in der Einheit *Stück* angegeben. +
Der ``plannedloadlistgroup_feeding_factor`` beschreibt den relativen Prozentsatz für die Anpassung der Futtermenge der Gruppe. (Standardwert 100%). Einheit *%*.

[source]
-----------------
// PlannedLoadListGroup – internal object
message PlannedLoadListGroup {

	UUID group_id_ref = 1;
	string plannedloadlistgroup_discharge_time = 2;		/// Expected start time. Datetime in ISO 8601 representation
	int32 plannedloadlistgroup_order = 3;				/// order in the list of groups to be fed. Unit piece
	int32 plannedloadlistgroup_feeding_factor = 4;		/// Relative percentage used to adjust feed amount for a group. (default 100%). Unit %
	repeated google.protobuf.Any extension = 2048;
}
-----------------

[#plannedloadlistresponse]
==== Antwort-Objekt zu einer übertragenden Ladeliste
Über das Objekt ``PlannedLoadListResponse`` wird zu einer übertragenden ``PlannedLoadList`` der Verarbeitungsstatus über den ``response_code`` zurückgegeben.

[source]
-----------------
message PlannedLoadListResponse {
    enum ResponseCode {
        OK = 0;                             /// No error occured
        CANNOT_PROCESS_PLANNEDLOADLIST = 2; /// Given PlannedLoadList cannot be processed
    }

    ResponseCode response_code = 1; /// Response code with processing information
    string response_text = 2;       /// Response text with human-readable information on why the PlannedLoadList cannot be processed

    repeated google.protobuf.Any extension = 2048;
}
-----------------

[#completeloadlistwithdependencies]
==== Abgeschlossene Fütterungsliste inklusiver notwendiger Masterdaten
Über das Objekt ``CompleteLoadListWithDependencies`` wird der Ist-Zustand einer Ladeliste beschrieben. 

[NOTE]
====
Dieses Objekt beinhaltet auch alle notwendigen (referenzierenten) Masterdaten.
====

[source]
-----------------
// CompleteLoadListWithDependencies for synchronization.
message CompleteLoadListWithDependencies {
	
    CompleteLoadList completeLoadList = 1;
    repeated Area area = 2;
    repeated Component component = 3;
    repeated Customer customer = 4;
    repeated Device device = 5;
    repeated Group group = 6;
    repeated Ingredient ingredient = 7;
    repeated Nutrients nutrients = 8;
    repeated Recipe recipe = 9;
    repeated Worker worker = 10;
    repeated google.protobuf.Any extension = 2048;
}
-----------------

[#completeloadlistwithdependenciesresponse]
==== Antwort-Objekt zu einer übertragenden abgeschlossenen Fütterungsliste
Über das Objekt ``CompleteLoadListWithDependenciesResponse`` wird zu einer übertragenden ``CompleteLoadListWithDependencies`` der Verarbeitungsstatus über den ``response_code`` zurückgegeben.

[source]
-----------------
message CompleteLoadListWithDependenciesResponse {
    enum ResponseCode {
        OK = 0;                                                 /// No error occured
        CANNOT_PROCESS_COMPLETELOADLISTWITHDEPENDENCIES = 2;    /// Given CompleteLoadListWithDependencies cannot be processed
    }

    ResponseCode response_code = 1; /// Response code with processing information
    string response_text = 2;       /// Response text with human-readable information on why the CompleteLoadListWithDependencies cannot be processed

    repeated google.protobuf.Any extension = 2048;
}
-----------------

[#completeloadlist]
==== Abgeschlossene Fütterungsliste
Über das Objekt ``CompleteLoadList`` wird der Ist-Zustand einer ``PlannedLoadList`` beschrieben. 

Das verwendete Futtermischwagen wird über den Parameter ``device_id_ref`` referenziert, gleiches gilt für den Mitarbeiter über ``worker_id_ref``. +
Die zugrundeliegende Ladeliste wird über ``plannedloadlist_id_ref`` referenziert. +
Der Start-, und Endezeitpunkt wird über ``completeloadlist_start_time`` respektive ``completeloadlist_end_time`` angegeben. +
Die geplante Fütterungsmenge in der Einheit *kg* wird über den Parameter ``completeloadlist_totalTheoreticalQty`` zurückgegeben und die tatsächlich verfütterte Menge (*kg*) über den Parameter ``completeloadlist_totalQty``.+
Der tatsächliche Befüll- und Mixvorgang zu jeder Zutat ist in der Liste ``completeLoadListIngredient`` vom Objektyp ``CompleteLoadListIngredient`` beschrieben. +
Über Liste ``completeLoadListGroup`` vom Objekttyp ``CompleteLoadListGroup`` sind die Tiergruppen konfiguriert die mit dieser Ladung gefüttert wurden.

[source]
-----------------
// CompleteLoadList – CLL
message CompleteLoadList {

	UUID completeloadlist_external_id = 1;								/// ID of the CompleteLoadList
	UUID device_id_ref = 2;												/// Internal reference
	UUID worker_id_ref = 3;												/// Internal reference
	UUID plannedloadlist_id_ref = 4;									/// Internal reference
	string completeloadlist_start_time = 5;								/// Start time the load is executed. Datetime in ISO 8601 representation
	string completeloadlist_end_time = 6;								/// End time the load is executed. Datetime in ISO 8601 representation
	double completeloadlist_totalTheoreticalQty = 7;					/// Total programmed quantity. Unit kg
	double completeloadlist_totalQty = 8;								/// Total real quantity. Unit kg
	repeated CompleteLoadListIngredient completeLoadListIngredient = 9; /// Included CompleteLoadListIngredient object
	repeated CompleteLoadListGroup completeLoadListGroup = 10; 			/// Included CompleteLoadListGroup object
	repeated google.protobuf.Any extension = 2048;
}
-----------------

[#completeloadlistingredient]
==== Abgeschlossener Befüllvorgang einer Zutat
Die zugrundeliegende Zutat wird über ``ingredient_id_ref`` referenziert.

Der Start-, und Endezeitpunkt der Befüllung wird über ``completeloadlistingredient_start_time`` respektive ``completeloadlistingredient_end_time`` dokumentiert. +
Die Beladungsreihenfolge wird über den Parameter ``completeloadlistingredient_order`` in der Einheit *Stück* beschrieben. +
Die ``completeloadlistingredient_realQty`` gibt die tatsächliche Menge in *kg* an. +
Die tatsächliche Mixzeit und die Mixgeschwindigkeit wird über ``completeloadlistingredient_real_mix_time`` und ``completeloadlistingredient_real_mix_speed`` dokumentiert.

[source]
-----------------
// CompleteLoadListIngredient – internal object
message CompleteLoadListIngredient {

	UUID ingredient_id_ref = 1;
	string completeloadlistingredient_start_time = 2;	    /// Start time of the load of each specific ingrdient. Datetime in ISO 8601 representation
	string completeloadlistingredient_end_time = 3;			/// End time of the load of each specific ingrdient.Datetime in ISO 8601 representation
	int32 completeloadlistingredient_order = 4;				/// Loading position/ sequence in load list. Unit piece
	double completeloadlistingredient_realQty = 5;	  		/// Total real quantity. Unit kg
	int32 completeloadlistingredient_real_mix_time = 6;		/// Total mix time. Unit sec
	int32 completeloadlistingredient_real_mix_speed = 7;	/// Total Mix rotations. Unit rpm
	repeated google.protobuf.Any extension = 2048;
}
-----------------

[#completeloadlistgroup]
==== Abgeschlossene Gruppenliste zu einer Ladeliste
Dokumentation einer Gruppen-Fütterung zu einer geplanten Ladeliste.

Die Referenz zu einer Gruppe ``(Group)`` erfolgt über die ``group_id_ref``. +
Das tatsächliche Start- und Endladedatum wird (im ISO 8601 Format) wird über  ``completeloadlistgroup_start_time`` und ``completeloadlistgroup_end_time`` dokumentiert. +
Die ``completeloadlistgroup_theoreticalQty`` gibt die geplante Menge in *kg* an, der Parameter ``completeloadlistgroup_realQty`` beschreibt die tatsächliche Menge in der Einheit *kg*.

[source]
-----------------
// CompleteLoadListGroup – internal object
message CompleteLoadListGroup {

	UUID group_id_ref = 1;
	string completeloadlistgroup_start_time = 2;	    /// Start time the load is executed. Datetime in ISO 8601 representation
	string completeloadlistgroup_end_time = 3;			/// End time. Datetime in ISO 8601 representation
	double completeloadlistgroup_theoreticalQty = 4; 	/// Total programmed quantity. Unit kg
	int32 completeloadlistgroup_realQty = 5;		    /// Total real quantity. Unit kg
	repeated google.protobuf.Any extension = 2048;
}
-----------------

[#completeloadlistresponse]
==== Antwort-Objekt zu einer abgeschlossenen Fütterungsliste
Über das Objekt ``CompleteLoadListResponse`` wird zu einer übertragenden ``CompleteLoadList`` der Verarbeitungsstatus über den ``response_code`` zurückgegeben.


[source]
-----------------
message CompleteLoadListResponse {
    enum ResponseCode {
        OK = 0;                                 /// No error occured
        CANNOT_PROCESS_COMPLETELOADLIST = 2;    /// Given CompleteLoadList cannot be processed
    }

    ResponseCode response_code = 1; /// Response code with processing information
    string response_text = 2;       /// Response text with human-readable information on why the CompleteLoadList cannot be processed

    repeated google.protobuf.Any extension = 2048;
}
-----------------

[#refusalwithdependencies]
==== Dokumentation einer Futterverweigerung inklusiver notwendiger Masterdaten
Dokumentation einer Futterverweigerung.

[NOTE]
====
Dieses Objekt beinhaltet auch alle notwendigen (referenzierenten) Masterdaten.
====

[source]
-----------------
// RefusalWithDependencies for synchronization (SYNC verb).
message RefusalWithDependencies {
	
    Refusal refusal = 1;
    repeated Group group = 2;
    repeated google.protobuf.Any extension = 2048;
}
-----------------

[#refusalwithdependenciesresponse]
==== Antwort-Objekt zu einer übertragenden Futterverweigerung
Über das Objekt ``RefusalWithDependenciesResponse`` wird zu einer übertragenden ``RefusalWithDependencies`` der Verarbeitungsstatus über den ``response_code`` zurückgegeben.

[source]
-----------------
message RefusalWithDependenciesResponse {
    enum ResponseCode {
        OK = 0;                                         /// No error occured
        CANNOT_PROCESS_REFUSALWITHDENPENDENCIES = 2;    /// Given RefusalWithDependencies cannot be processed
    }

    ResponseCode response_code = 1; /// Response code with processing information
    string response_text = 2;       /// Response text with human-readable information on why the RefusalWithDependencies cannot be processed

    repeated google.protobuf.Any extension = 2048;
}
-----------------

[#refusal]
==== Dokumentation einer Futterverweigerung
Die Gruppe für die die Verweigung dokumentiert wird ist über den Parameter ``group_id_ref`` referenziert.

Der Dokumentationszeitpunkt wird im ISO 8601 Format über ``refusal_time`` beschrieben.
Die Menge in *kg* wird über ``refusal_totalQty`` angegeben.

[source]
-----------------
// Refusal – RFL 
message Refusal {

	UUID refusal_external_id = 1;	/// Uniquely references for the refusal in the sofware system used
	UUID group_id_ref = 2;			/// Internal reference
	string refusal_time = 3;	    /// Time of collection. Datetime in ISO 8601 representation
	double refusal_totalQty = 4;	/// Quantity (kg/lb/etc..) of refused collected. Unit kg
	repeated google.protobuf.Any extension = 2048;
}
-----------------

[#refusalresponse]
==== Antwort-Objekt zu einer übertragenden Futter Verweigerung 
Über das Objekt ``RefusalResponse`` wird zu einem übertragenden ``Refusal`` der Verarbeitungsstatus über den ``response_code`` zurückgegeben.

[source]
-----------------
message RefusalResponse {
    enum ResponseCode {
        OK = 0;                     /// No error occured
        CANNOT_PROCESS_REFUSAL = 2; /// Given Refusal cannot be processed
    }

    ResponseCode response_code = 1; /// Response code with processing information
    string response_text = 2;       /// Response text with human-readable information on why the Refusal cannot be processed

    repeated google.protobuf.Any extension = 2048;
}
-----------------

==== Generisches Nachrichten Objekt
Generisches Objekt zum Datenaustausch *eines* Feedmixer Objekts.

[NOTE]
====
Wird nur in Verbindung einer ``ElementOperation`` verwendet.
====

[source]
-----------------
message Element {
    oneof element {
        Area area = 1;
        Component component = 2;
        Customer customer = 3;
        Device device = 4;
        Group group = 5;
        Ingredient ingredient = 6;
        MasterData masterData = 7;
        Recipe recipe = 8;
        Worker worker = 9;
        PlannedLoadListWithDependencies plannedLoadListWithDependencies = 10;
        PlannedLoadList plannedLoadList = 11;
        CompleteLoadListWithDependencies completeLoadListWithDependencies = 12;
        CompleteLoadList completeLoadList = 13;
        RefusalWithDependencies refusalWithDependencies = 14;
        Refusal refusal = 15;
    }

    repeated google.protobuf.Any extension = 2048;  /// Used for proprietary purposes
}
-----------------

==== Generisches Objekt zum Datenaustausch 
Über das Objekt ``ElementOperation`` kann jedes Feedmixer Objekt *unabhängig* zu einem Szenario-Flow überstellt werden. 

Über den ``ElementOperationType`` wird dem Empfänger mitgeteilt, wie er die überstellten Objekte verarbeiten muss (``UPDATE, CREATE, REPLACE, DELETE``) repektive welches Feedmixer-Objekt über den Type ``REQUEST`` angefragt wird. +
Über den Parameter ``Element`` wird *ein* Feedmixer-Objekt zu dieser Operation angebeben.

[source]
-----------------
 message ElementOperation {
	enum ElementOperationType {
		UNDEFINED = 0;
		UPDATE = 1;		/// If the given element exists it will be updated, element is identified by UID (is inside the specific ISO11783-10 element)
		CREATE = 2;		/// Inserts the given element, element does not need to have an UID (is inside the specific ISO11783-10 element). If the element has an UID it will be created with the given UID. If the given UID already exists the element will not be created and an appropriate error code will be returned
		REPLACE = 3;	/// If the given element does not exist it will be created. If the element exists, it will be updated. Element is identified by UID (is inside the specific ISO11783-10 element)
		DELETE = 4;		/// Deletes the given element identified by UID (is inside the specific ISO11783-10 element). If operation was successful, the reply message has an empty element field
		REQUEST = 5;	/// Requests an element by sending the message of the specific type with an UID (is inside the specific ISO11783-10 element)
    }
    
	ElementOperationType operation = 1; /// Describes the type of the operation which is defined above
    Element element = 2;                /// Element the operation is requested for
    
	repeated google.protobuf.Any extension = 2048;
}
-----------------

==== Antwort-Objekt zu einer ElementOperation
Über das Objekt ``ElementOperationResponse`` wird zu einem übertragenden ``ElementOperation`` der Verarbeitungsstatus über den ``response_code`` zurückgegeben.

Zusätzlich wird über den Parameter ``Element`` das zuvor übertragende Objekt nach seiner Verarbeitung (``UPDATE, CREATE, REPLACE, DELETE``) respektive das über den Operation-Type ``REQUEST`` angefragte Objekt übergeben.

[source]
-----------------
 message ElementOperationResponse {
    enum ResponseCode {
        OK = 0;                 /// No error occured
        OPERATION_FAILED = 1;   /// Requested operation failed
    }
        
    ResponseCode response_code = 1; /// Response code with processing information
    Element element = 2;            /// Contains the corresponding element after the operation was performed, after a delete operation the element is empty
    
	repeated google.protobuf.Any extension = 2048;
}
-----------------

[#efdi-concept]
== Beschreibung zum ISO 5231 (EFDI) Standard

Die ISO 5231 "Extended Farm Management Information Systems Data Interface" (EFDI) beschreibt ein standardisiertes Datenmodell und eine Kommunikationsschnittstelle, 
die darauf abzielt, Informationen zwischen landwirtschaftlichen Managementsystemen (Herdenmanagement, Futtermanagement oder Farm Management Information Systems) 
und anderen Systemen wie Maschinen, Sensoren oder externen Dienstleistungen effizient auszutauschen. 
Das Konzept der *Szenarien Flows* innerhalb der Norm bietet einen Rahmen, um typische Arbeitsabläufe strukturiert zu modellieren und deren Datenflüsse zu standardisieren.

### Allgemeine Beschreibung der Szenarien Flows
Die *Szenarien Flows* sind eine methodische Darstellung von Anwendungsfällen und Arbeitsabläufen. 
Sie dienen dazu, den Informationsaustausch zwischen verschiedenen Akteuren und Systemen zu harmonisieren und zu dokumentieren. 
Dies geschieht durch die Definition von standardisierten Datenstrukturen und Prozessen. 
Die wichtigsten Merkmale des Konzepts sind:

1. **Zielorientierung**  
   Jeder Szenario Flow repräsentiert einen spezifischen Arbeitsprozess oder Anwendungsfall, z. B. die Planung und Durchführung von Fütterungen, Düngung, Ernte oder die Überwachung von Tierbeständen.

2. **Akteure und Systeme**  
   Die Flows berücksichtigen die verschiedenen Akteure (z. B. Landwirt, Berater, Dienstleister) sowie die beteiligten Systeme (z.B. Herden- Futtermanagement Systemen, Maschinensteuerungen, Sensoren).

3. **Standardisierte Datenstrukturen**  
   Die Norm legt fest, welche Datenformate und -protokolle verwendet werden, um sicherzustellen, dass unterschiedliche Systeme miteinander kommunizieren können.

4. **Modellierung von Arbeitsabläufen**  
   Die Abläufe werden in logischen Schritten modelliert, die den Informationsfluss vom Start (z. B. Planung) über die Ausführung bis zur Dokumentation und Auswertung abbilden.

5. **Interoperabilität und Skalierbarkeit**  
   Durch die standardisierte Definition der Daten und Prozesse können verschiedene Systeme nahtlos miteinander arbeiten, unabhängig von Hersteller oder Softwareumgebung. Dies fördert die Interoperabilität und Skalierbarkeit für kleine und große Betriebe.

6. **Beispiele für Szenarien Flows**  
   - **Planungsprozess:** Erstellen einer Rationsplanung im Herdenmanagment System, Übermittlung der Daten an den Futtermischwagen, Rückmeldung der ausgeführten Maßnahmen.  
   - **Echtzeitüberwachung:** Sammeln von Sensordaten (z. B. Wetterstation), Auswertung in Echtzeit und automatisierte Anpassung von Maßnahmen.  
   - **Dokumentation:** Automatische Erfassung von Maschinendaten während der Feldarbeit und Integration in gesetzliche Dokumentationsanforderungen.

7. **Integration und Erweiterung**  
   Die Szenarien Flows lassen sich an spezifische Bedürfnisse und Technologien anpassen, während sie gleichzeitig die Kompatibilität mit anderen Standards und Systemen wahren.

### Vorteile der Szenarien Flows
- **Effizienzsteigerung:** Automatisierter Informationsaustausch reduziert manuelle Eingaben und Fehler.
- **Transparenz:** Klar definierte Prozesse und Datenströme fördern eine bessere Nachvollziehbarkeit der Arbeitsabläufe.
- **Flexibilität:** Möglichkeit, neue Technologien und Anwendungsfälle zu integrieren.
- **Kostensenkung:** Standardisierte Schnittstellen reduzieren Entwicklungs- und Integrationskosten für Hersteller und Betriebe.

== Mögliche Szenarien Flows im Kontext FeedMixer

[cols="1,1"]
|===
|link:#flow-masterdata[``Szenario Flow: Sync Masterdata``]
|Szenario Flow: Synchronisation von Stamm- oder Masterdaten

|link:#flow-plannedloadlist[``Szenario Flow: PlannedLoadList``]
|Szenario Flow: Austausch einer Ladeliste

|link:#flow-plannedloadlistwithdependencies[``Szenario Flow: PlannedLoadListWithDependencies``]
|Szenario Flow: Austausch einer Ladeliste mit allen notwendigen Masterdaten

|link:#flow-completeloadlist[``Szenario Flow: CompleteLoadList``]
|Szenario Flow: Austausch einer abgeschlossenen Fütterungsliste

|link:#flow-completeloadlistwithdependencies[``Szenario Flow: CompleteLoadListWithDependencies``]
|Szenario Flow: Austausch einer abgeschlossenen Fütterungsliste mit allen notwendigen Masterdaten

|link:#flow-refusal[``Szenario Flow: Refusal``]
|Szenario Flow: Austausch einer Futterverweigerung

|link:#flow-refusalwithdependencies[``Szenario Flow: RefusalWithDependencies``]
|Szenario Flow: Austausch einer Futterverweigerung mit allen notwendigen Masterdaten
|===

In diesen Szenarien geht es darum, eine Liste geplanter Beladungen für einen Futtermischwagen zu erstellen, zu verwalten und zwischen verschiedenen Systemen auszutauschen. 
Dies umfasst typischerweise die folgenden Schritte:

1. **Planung der Futterrationen**: Ein Herden- oder Futtermanagement System erstellt basierend auf den Ernährungsbedürfnissen der Tiere und verfügbaren Futterressourcen eine detaillierte Futterration.

2. **Erstellung der Beladeliste**: Basierend auf der geplanten Futterration wird eine spezifische Beladeliste für den Futtermischwagen erstellt, die die genauen Mengen und Arten von Futtermitteln angibt, die geladen werden sollen.

3. **Übermittlung an den Futtermischwagen**: Die erstellte Beladeliste wird elektronisch an das Steuerungssystem des Futtermischwagens übertragen, um den Lade- und Mischprozess zu steuern.

4. **Durchführung des Mischvorgangs**: Der Futtermischwagen führt den Mischvorgang gemäß der erhaltenen Beladeliste durch und stellt sicher, dass die Tiere die geplante Futterration erhalten.

5. **Rückmeldung und Dokumentation**: Nach Abschluss des Misch- und Fütterungsvorgangs werden die tatsächlich geladenen und verteilten Futtermengen zurück an das Herden- oder Futtermanagement gemeldet, um die Fütterungsdaten zu dokumentieren und für zukünftige Analysen bereitzustellen.

6. **Futter Verweigerung einer Tiergruppe**: Futtermengen zur einer Tiergruppe die verweigert wurden, können zurück an das Herden- oder Futtermanagement gemeldet werden, um diese zu dokumentieren und für zukünftige Analysen bereitzustellen.

Diese Szenarien stellen sicher, dass der gesamte Prozess der Futterplanung, -mischung und -verteilung effizient und genau durchgeführt wird, indem es eine nahtlose Kommunikation und Datenintegration zwischen Herden- oder Futtermanagement Systemen und Futtermischwagen ermöglicht.

[NOTE]
====
Eine Besonderheit besteht darin, dass einige der Bewegungsdaten z.B. einer ``PlannedLoadList`` mit allen notwendigen (referenzierenten) Masterdaten oder nur mit einer Referenz übertragen werden können.

Die Stammdaten/Masterdaten können über das Objekt ``MasterData`` synchronisiert werden, dieses Vorgehen wird über den Scenario-Flow (Sync MasterData) beschrieben.

Nach einer Sychronisierung der Masterdaten können die Objekte mit nur einer Referenz auf die Masterdaten verwendet werden, z.B. ``PlannedLoadList`` oder ``CompleteLoadList``.
====

[#flow-masterdata]
== Szenario Flow: Synchronisation von Stamm- oder Masterdaten
Stamm- oder Masterdaten können über das Objekt ``MasterData`` zur Synchronisation ausgetauscht werden. 
Der Empfänger speichert sämtliche oder die aktualisiernten Masterdaten in seiner Datenbank/Filesystem.

Der Status der Verarbeitung wird über das Objekt ``MasterDataResponse`` an den Sender übertragen.

[#flow-plannedloadlist]
== Szenario Flow: Austausch einer Ladeliste
Dieser Szenario Flow beschreibt den Datenaustausch einer ``PlannedLoadList``,z.B. aus einem Herdenmanagement System auf einen Futtermischwagen.
Der Status der Verarbeitung wird über das Objekt ``PlannedLoadListResponse`` an den Sender übertragen.

Der Empfänger (Futtermischwagen) versucht im ersten Schritt die Refenrenzen der notwendigen Objekte über seine gespeicherten Objekte aufzulösen.
Ist dieses erfolgreich wird als ``ResponseCode`` bei der ``PlannedLoadListResponse`` ``OK`` verwendet und damit die erfolgreiche Verarbeitung quittiert.

Konnte hingegen eine oder mehrere Referenzen nicht aufgelöst werden, wird als ``ResponseCode`` bei der ``PlannedLoadListResponse`` ``CANNOT_PROCESS_PLANNEDLOADLIST`` verwendet.
Dieses signalisiert dem Sender (Herdenmanagement System), dass notwendigen Masterdaten auf dem Futtermischwagen fehlen und eine Synchronisation der Masterdaten angetriggert werden muss.
Siehe dazu: link:#flow-masterdata[Szenario Flow - Synchronisation von Stamm- oder Masterdaten] 

[#flow-plannedloadlistwithdependencies]
== Szenario Flow: Austausch einer Ladeliste mit allen notwendigen Masterdaten
Dieser Szenario Flow beschreibt den Datenaustausch einer ``PlannedLoadListWithDependencies``,z.B. aus einem Herdenmanagement System auf einen Futtermischwagen.
Der Status der Verarbeitung wird über das Objekt ``PlannedLoadListWithDependenciesResponse`` an den Sender übertragen.

Der Empfänger (Futtermischwagen) versucht im ersten Schritt die Refenrenzen der notwendigen Objekte über seine gespeicherten Objekte aufzulösen.
Ist dieses erfolgreich wird als ``ResponseCode`` bei der ``PlannedLoadListWithDependenciesResponse`` ``OK`` verwendet und damit die erfolgreiche Verarbeitung quittiert.

Konnte hingegen eine oder mehrere Referenzen nicht aufgelöst werden, wird als ``ResponseCode`` bei der ``PlannedLoadListWithDependenciesResponse`` ``CANNOT_PROCESS_PLANNEDLOADLISTWITHDEPENDENCIES`` verwendet.
Dieses signalisiert dem Sender (Herdenmanagement System), dass der Inhalt der Ladeliste nicht korrekt ist und überprüft/korrigiert und damit neu versendet werden muss.

[#flow-completeloadlist]
== Szenario Flow: Austausch einer abgeschlossenen Fütterungsliste
Dieser Szenario Flow beschreibt den Datenaustausch einer ``CompleteLoadList`` von einem Futtermischwagen zum Herden- oder Futtermanagent System.
Der Status der Verarbeitung wird über das Objekt ``CompleteLoadListResponse`` an den Sender übertragen.

Der Empfänger (Herden- Futtermangement) versucht im ersten Schritt die Refenrenzen der übertragenden Objekte aufzulösen.
Ist dieses erfolgreich wird als ``ResponseCode`` bei der ``CompleteLoadListResponse`` ``OK`` verwendet und damit die erfolgreiche Verarbeitung quittiert.

Konnte hingegen eine oder mehrere Referenzen nicht aufgelöst werden, wird als ``ResponseCode`` bei der ``CompleteLoadListResponse`` ``CANNOT_PROCESS_COMPLETELOADLIST`` verwendet.
Dieses signalisiert dem Sender (Futtermischwagen), dass notwendigen Masterdaten fehlen und eine Synchronisation der Masterdaten angetriggert werden muss.
Siehe dazu: link:#flow-masterdata[Szenario Flow - Synchronisation von Stamm- oder Masterdaten] 

[#flow-completeloadlistwithdependencies]
== Szenario Flow: Austausch einer abgeschlossenen Fütterungsliste mit allen notwendigen Masterdaten
Dieser Szenario Flow beschreibt den Datenaustausch einer ``CompleteLoadListWithDependencies`` von einem Futtermischwagen zu einem Herden- oder Futtermanagent System.
Der Status der Verarbeitung wird über das Objekt ``CompleteLoadListWithDependenciesResponse`` an den Sender übertragen.

Der Empfänger (Herden- Futtermangement) versucht im ersten Schritt die Refenrenzen der notwendigen Objekte über seine gespeicherten Objekte aufzulösen.
Ist dieses erfolgreich wird als ``ResponseCode`` bei der ``CompleteLoadListWithDependenciesResponse`` ``OK`` verwendet und damit die erfolgreiche Verarbeitung quittiert.

Konnte hingegen eine oder mehrere Referenzen nicht aufgelöst werden, wird als ``ResponseCode`` bei der ``CompleteLoadListWithDependenciesResponse`` ``CANNOT_PROCESS_COMPLETELOADLISTWITHDEPENDENCIES`` verwendet.
Dieses signalisiert dem Sender (Futtermischwagen), dass der Inhalt der abgeschlossenen Ladeliste nicht korrekt ist. Diese muss überprüft und korrigiert werden, damit diese neu versendet werden kann.

[#flow-refusal]
== Szenario Flow: Austausch einer Futterverweigerung
Dieser Szenario Flow beschreibt den Datenaustausch des ``Refusal`` Objektes von einem Futtermischwagen zu einem Herden- oder Futtermanagent System.
Der Status der Verarbeitung wird über das Objekt ``RefusalResponse`` an den Sender übertragen.

Der Empfänger (Herden- Futtermangement) versucht im ersten Schritt die Refenrenzen der notwendigen Objekte über seine gespeicherten Objekte aufzulösen.
Ist dieses erfolgreich wird als ``ResponseCode`` bei der ``RefusalResponse`` ``OK`` verwendet und damit die erfolgreiche Verarbeitung quittiert.

Konnte hingegen eine oder mehrere Referenzen nicht aufgelöst werden, wird als ``ResponseCode`` bei der ``RefusalResponse`` ``CANNOT_PROCESS_REFUSAL`` verwendet.
Dieses signalisiert dem Sender (Futtermischwagen), dass der Inhalt zur Futterverweigerung nicht korrekt ist. Diese muss überprüft und korrigiert werden, damit diese neu versendet werden kann.

[#flow-refusalwithdependencies]
== Szenario Flow: Austausch einer Futterverweigerung mit allen notwendigen Masterdaten
Dieser Szenario Flow beschreibt den Datenaustausch einer ``RefusalWithDependencies`` von einem Futtermischwagen zu einem Herden- oder Futtermanagent System.
Der Status der Verarbeitung wird über das Objekt ``RefusalWithDependenciesResponse`` an den Sender übertragen.

Der Empfänger (Herden- Futtermangement) versucht im ersten Schritt die Refenrenzen der notwendigen Objekte über seine gespeicherten Objekte aufzulösen.
Ist dieses erfolgreich wird als ``ResponseCode`` bei der ``RefusalWithDependenciesResponse`` ``OK`` verwendet und damit die erfolgreiche Verarbeitung quittiert.

Konnte hingegen eine oder mehrere Referenzen nicht aufgelöst werden, wird als ``ResponseCode`` bei der ``RefusalWithDependenciesResponse`` ``CANNOT_PROCESS_REFUSALWITHDENPENDENCIES`` verwendet.
Dieses signalisiert dem Sender (Futtermischwagen), dass der Inhalt zur zur Futterverweigerung nicht korrekt ist. Diese muss überprüft und korrigiert werden, damit diese neu versendet werden kann.





















